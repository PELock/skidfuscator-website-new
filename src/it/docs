## Cifratura Numero

Il trasformatore di crittografia numerica crittografa qualsiasi numerale basato su interi da nascondere. Questo è perfetto per brutto il codice in generale e renderlo più difficile per gli ingegneri invertiti per ottenere un codice sorgente pulito. Questo rafforza inoltre qualsiasi condizionale booleano.

La crittografia numerica si basa sull'offuscamento del flusso GEN3 e può, in uscita decompilata, mostrare come segue

Assume il seguente scenario:
- $x$ è il numero che vogliamo crittografare
- $n$ è il "seed" del blocco
- $d$ è il numero crittografato

Secondo la semplice meccanica xor: $x\oplus n\oplus n=x$

Quindi, per definizione, se $n$ è il nostro seme, al runtime dobbiamo calcolare $d$ come $d = x\oplus n$. Poi, dobbiamo modificare le istruzioni di bytecode come:

```java
int value = x;
```

diventa
```java
int value = x;
```

Dove $d$ è il valore calcolato prima del tempo sotto forma di costante e $n$ il predicato opaco. Esempio:
```java
int valore = 5;
```
diventa
```java
int predicate = 0x100;
int value = 105 ^ predicate;
```

## Configurazione

Attualmente, c'è solo una modalità di cifratura numerica, `STANDARD`

```js
numberEncryption {
    enabled: true
    exempt: []
}
```

## Esempi
#### Unofuscato
```java
int var = 1000;
System.out.println(var + 1 + 2 + 3);
```

#### Offuscato
```java
int var = 0xA0290233 ^ n;
System.out.println(var + 0x92083838 ^ n + 0x92083839 ^ n + 0x92083840 ^ n);
```

