## Renamer Metodo

Il rinominatore del metodo cerca di rinominare con precisione un intero metodo per impedire la conservazione dei nomi del metodo. Per ottenere questo, Skidfuscator crea "gruppi di metodo" per preservare efficacemente il metodo hierachy. Ad esempio, se la `classe B` estende la `classe A` e la `classe A` implementa il `metodoA()`, tutte le chiamate a `metodoA()` sia per la `classe A` che per la `classe B` dovrà essere rinominato.

## Configurazione
Il rinominatore del metodo attualmente supporta un dizionario, `ALPHABETICAL`, accanto al dizionario personalizzato tradizionale, `CUSTOM`, basato su input. In questo scenario, sono disponibili le seguenti opzioni:
- Profondità: quanti letterali saranno usati per impostazione predefinita (es.: 3 profondità porterà a o0o0o0 per il primo elemento, o 1 profondità porterà a o0 per il primo elemento)
- Caratteri: Caratteri che devono essere utilizzati dal trasformatore.

::: warning
Al momento, il trasformatore non gestisce caratteri duplicati e creerà in modo improprio nomi di metodo identici. Ad esempio, non usare "o", "0" e "o0" in quanto quest'ultimo è una combinazione dei due caratteri precedenti.
:::

```js
methodRenamer {
    enabled: false
    type: CUSTOM // or 'ALPHABETICAL'
    chars: [
        "K"
        "oO",
        "o0"
    ]
    depth: 3
}
```

## Esempi

#### Unofuscato

```java
public static void main(String[] args) {
    int number = callNumber();
    /*[...]*/
}

static int callNumber() {
    return 1;
}
```

#### Offuscato
```java
public static void main(String[] args) {
    int number = o0k0k0Kk();
    /*[...]*/
}


static int o0k0k0Kk() {
    return 1;
}
```