
# Yapılandırma

Burada yapılandırmanın neler sunduğu hakkında her şeyi öğreneceksin. Buradaki detayları bir kartal gibi keskin oku. Eğer herhangi bir sorunla karşılaşırsan, lütfen destekle iletişime geç. Premium üyeleri, takımımız tarafından ücretsiz yapılandırma hizmetine tabii tutulur.

## Yapılandırmanın temelleri

Yapılandırmanın temeli [lightbend config](https://github.com/lightbend/config)'e dayanır. Bu demektir ki varsayılan olarak şu üç yapılandırma formatını destekliyoruz: Java Properties, JSON ve HOCON.

Prensip olarak, sade, daha şık ve çok yönlü kolay kullanımı nedeniyle **HOCON kullanmanızı şiddetle tavsiye ediyoruz**. İşte varsayılan yapılandırma:

```javascript
exempt: []

libs: []

stringEncryption {
  type: STANDARD
  enabled: true
  exempt: []
}

numberEncryption {
  enabled: true
  exempt: []
}

intAnnotationEncryption {
  enabled: true
  exempt: []
}

stringAnnotationEncryption {
  enabled: true
  exempt: []
}

exceptionReturn {
  enabled: true
  exempt: []
}

flowCondition {
  enabled: true
  exempt: []
}

flowException {
  enabled: true
  strength: AGGRESSIVE
  exempt: []
}

flowRange {
  enabled: true
  exempt: []
}

flowFactoryMaker {
  enabled: true
  exempt: []
}

flowSwitch {
  enabled: true
  exempt: []
}

outliner {
  enabled: true
  exempt: []
}

ahegao {
  enabled: true
  exempt: []
}

native: {
  enabled: false
  exempt: []
}

driver: {
  enabled: false
}

reference {
  enabled: false
}

fileCrasher: {
  enabled: false
}

classRenamer {
  enabled: false
  type: CUSTOM
  prefix: "skido/"
  chars: [
    "K"
    "oO",
    "o0"
  ]
  depth: 3
}

methodRenamer {
  enabled: false
  type: CUSTOM
  chars: [
    "K"
    "oO",
    "o0"
  ]
  depth: 3
}

fieldRenamer {
  enabled: false
  type: ALPHABETICAL
}
```

## Ayrıştırmalar

Ayrıştırmaların kullanımı eski sistemde nasıl yapılıyorsa aynen öyle. Ayrıştırmalar hakkında daha fazla şey öğrenmek için, [şu sayfaya](../exclusion.md) gidin

::: warning 
Java stringleri ters slaşı ayrıştırarak sunar. Bu da demek ki tüm ters slaşları MUTLAKA çift kullanmalısınız
:::

### Bir sınıfı ayrıştırmak

Başlarken temel olarak, belli bir sınıfı ayrıştırmak için, sınıf regex ayrıştırmasını kullanmalısın:
```js
class{^benim\/sinifim}
```

Bunu yapılandırmada kullanmak için, bir string olarak girmelisin.


```js
exempt: [
    "class{^benim\\/sinifim}"
]
```

### Bir metodu ayrıştırmak

Başlarken temel olarak, belli bir metodu ayrıştırmak için, metod regex ayrıştırmasını kullanmalısın:
```js
method{^benimMetodum}
```

Bunu yapılandırmada kullanmak için, bir string olarak girmelisin.

```js
exempt: [
    "method{^benimMetodum}"
]
```

### Belli bir sınıfta bir metodu ayrıştırmak

Aynı az önce öğrendiğimiz gibi, bir metodu ve bir sınıfı ayrıştırmak için şunu yapmalıyız:
```js
class{^benim\/sinifim}
method{^benimMetodum}
```

Şimdi, belli bir sınıfın İÇİNDE bir metodu ayrıştırmak için, yapılması gereken tek şey bu ikisinin tek bir satırda birleştirilmesidir, örnek olarak:

```js
class{^benim\/sinifim} method{^benimMetodum}
```

Dolayısıyla yapılandırmada şu şekilde olur:

```js
exempt: [
    "class{^benim\/sinifim} method{^benimMetodum}"
]
```

## Kütüphaneler

Libraries are an important aspect of computing the classpath and ensuring maximum protection for your software. In this instance, you must provide a valid Java path argument as a string

Here below is the implementation code:
```java
public File[] getLibs() {
    return this.getStringList("libraries", Collections.emptyList())
                .stream()
                .map(File::new)
                .distinct()
                .toArray(File[]::new);
}
```

Here below is an example of valid java paths:
```
C:\test.jar
test.jar
./test.jar
/Home/test.jar
```

In the config, these would be represented as follows:

```js
libraries [
    "C:\\test.jar",
    "test.jar",
    "./test.jar",
    "/Home/test.jar"
]
```

## Driver

The driver is the hardening part of Skidfuscator. This feature is reserved to Premium. In a nutshell, per obfuscation, a new driver is generated and compiled for the following architectures:

| Operating System | Supported Architectures |
| ---------------- | ----------------------- |
| Windows          | x64_86                  |
| MacOS            | x64_86, AARCH64 (ARM)   |
| Linux            | x64_86 (AMD64)          |

To disable this feature (:warning: this significantly decreases obfuscation strength), you must toggle the boolean:

```js
driver: false
```


## Transformers

You can individually enable/disable each transformer.


#### String Encryption

The string encryption transformer transforms every string into a specific method call, with the purpose of hiding it in runtime. This can be practical for non-sensitive URLs, private keys, etc...

::: warning
You should not trust the client as a basis. Please do not rely on String encryption as the sole protection for your software. By default, you should assume that a talented enough reverse-engineer could gain access to these with enough time and patience.
:::

There are currently two modes for String encryption: `STANDARD` and `POLYMORPHIC`

#### Number Encryption

The number encryption transformer encrypts any integer-based numeral to be hidden. This is perfect for uglifying the code in general and making it more of a hardship for reverse-engineers to obtain a clean source code. This furthermore reinforces any boolean-based conditionals.


#### 