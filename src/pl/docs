# Transformers

Oto indeks, w którym będę szczegółowo opisywał każdy transformator jeden po drugim. Powinno to pomóc w zrozumieniu, co dzieje się za kulisami i jak takie transformacje są skuteczne przeciwko inżynierii wstecznej.

Omówimy poniższy indeks:
- Szyfrowanie Liczb
- Szyfrowanie stringów

## Szyfrowanie Liczb

Przyjmijmy następujący scenariusz:
- $x$ to liczba, którą chcemy zaszyfrować
- $n$ to "ziarno" bloku
- $d$ jest zaszyfrowaną liczbą

Zgodnie z prostą mechaniką xor: $x\oplus n\oplus n=x$

Tak więc, z definicji, jeśli $n$ jest naszym seedem, w czasie wykonywania musimy obliczyć $d$ w taki sposób, że $d = x\oplus n$. Następnie musimy zmodyfikować instrukcję kodu bajtowego, np:

```java
int value = x;
```

staje się
```java
int value = d ^ n;
```

Gdzie $d$ jest wartością obliczoną z wyprzedzeniem w postaci stałej, a $n$ nieprzezroczystym predykatem. Np:
```java
int value = 5;
```
staje się
```java
int predicate = 0x100;
int value = 105 ^ predicate;
```

## Szyfrowanie stringów

Szyfrowanie ciągów znaków opiera się na trzech podstawowych warunkach przed ich przetworzeniem:
1. Stała łańcuchowa musi być dostępna w puli stałych
2. Stała łańcuchowa musi być sformatowana w UTF-8
3. Ciąg znaków nie może być pusty

Dzięki temu jesteśmy w stanie wstrzyknąć symetryczny system szyfrowania wewnątrz kodu, aby móc ukryć ciąg przed typowymi dekompilatorami / deasemblerami.

### Algorytm Xor

W tej chwili używamy prostego algorytmu xor, który jest dość odporny, aby móc obliczyć nasz zaszyfrowany ciąg. Chociaż algorytm ten jest matematycznie najgorszej jakości i najprawdopodobniej można go złamać w czasie wielomianowym, jeśli nie liniowym, naszym celem jest zaproponowanie łatwej i sprawdzonej implementacji tego, jak nieprzezroczysty predykat może wzmocnić szyfrowanie ciągów znaków. W przyszłych wersjach Skidfuscatora będziemy korzystać z silnika polimorficznego.

Obecnie algorytm działa w ten sposób:

Niech $f_y(x)=x\oplus y\oplus n$ reprezentuje metodę szyfrowania i deszyfrowania znaku w ciągu znaków dla danego $n$ i $m_{max}$ równego 255

$y=i\mod m$

gdzie $i$ reprezentuje indeks znaku w łańcuchu String, $m$ reprezentuje rozmiar losowej tablicy liczb całkowitych z losowymi "kluczami", $n$ reprezentuje nieprzezroczysty predykat liczby całkowitej, $x$ znak na indeksie $i$ łańcucha String.

Według definicji: $$ \begin{align} f_y(f_y(x))&=x\oplus y\oplus n\oplus y\oplus n\\
&=x\oplus y\oplus y\oplus n\oplus n\\ f_y(f_y(x))&=x \end{align} $$

W ten sposób otrzymujemy użyteczny algorytm szyfrowania/deszyfrowania, który jest wzmocniony przez nieprzezroczysty predykat i zestaw kluczy całkowitych przechowywanych lokalnie. Implementację można zobaczyć [tutaj](https://github.com/terminalsin/skidfuscator-java-obfuscator/blob/master/dev.skidfuscator.obfuscator/obfuscator/src/main/java/dev/skidfuscator/obfuscator/transform/impl/string/BasicEncryptionGenerator.java)

Konturowanie odnosi się do procesu wyodrębniania kodu z metody i umieszczania go w oddzielnej, samodzielnej metodzie. Jest to często sposób na poprawę czytelności i łatwości konserwacji kodu, ponieważ może ułatwić zrozumienie, co robi metoda, dzieląc ją na mniejsze, bardziej skoncentrowane fragmenty kodu.

Konturowanie może być również wykorzystywane jako forma zaciemniania kodu, ponieważ może utrudnić komuś, kto próbuje przeprowadzić inżynierię wsteczną lub zrozumieć kod, zobaczenie ogólnego przepływu i struktury programu. Rozbijając kod na mniejsze części i rozdzielając go na różne metody, ktoś może być znacznie trudniejszy do zrozumienia relacji między różnymi częściami przepływu i tego, jak pasują do siebie, aby wykonać określoną funkcję.

![Graficzne wyjaśnienie konspektu](https://i.imgur.com/2HMq0a4.png)

Fantastyczną rzeczą w obrysie jest to, że nie jest *technicznie* odwracalny, ponieważ został wyprodukowany we franczie! Aby móc powrócić do pierwotnego stanu dobrej obfuskacji, deobfuscator *musi wykonać inlining*, co jest heurystyką i *nie gwarantuje*, że dane wyjściowe będą zawsze semantycznie poprawne z oryginalnym kodem zródłowym. Co więcej, wymaga to od deobfuscatora manipulowania zmiennymi i innymi wrażliwymi formami manipulacji kodem bajtowym, co może prowadzić do wyjątków ramek i obliczeń.

Ogólnie rzecz biorąc, zarys obfuskacja jest całkiem fajna :)
