import{ab as n,G as i,H as d,F as e,U as t,N as r,ac as a,X as s}from"./framework-b3e398e9.js";const c={},h=a('<h1 id="üïµÔ∏è-what-is-skidfuscator" tabindex="-1"><a class="header-anchor" href="#üïµÔ∏è-what-is-skidfuscator" aria-hidden="true">#</a> üïµÔ∏è What is Skidfuscator?</h1><p>Skidfuscator is a proof of concept obfuscation tool designed to take advantage of SSA form to optimize and obfuscate Java bytecode code flow. This is done via intra-procedural passes each designed to mingle the code in a shape where neither the time complexity neither the space complexity suffers from a great loss. To achieve the such, we have modeled a couple of well known tricks to add a significant strength to the obfuscation whilst at the same time retaining a stable enough execution time.</p><h1 id="‚ú®-features" tabindex="-1"><a class="header-anchor" href="#‚ú®-features" aria-hidden="true">#</a> ‚ú® Features</h1><p>Here are all the cool features I&#39;ve been adding to Skidfuscator. It&#39;s a fun project hence don&#39;t expect too much from it. It&#39;s purpose is not to be commercial but to inspire some more clever approaches to code flow obfuscation, especially ones which make use of SSA and CFGs</p><figure><img src="https://i.ibb.co/4MQnj4V/FE185-E3-B-0-D0-D-4-ACC-81-AA-A4862-DF01-FA3.gif" alt="Cool gif" tabindex="0" loading="lazy"><figcaption>Cool gif</figcaption></figure><h2 id="third-generation-flow" tabindex="-1"><a class="header-anchor" href="#third-generation-flow" aria-hidden="true">#</a> Third Generation Flow</h2>',6),l={href:"https://www.zelix.com/klassmaster/featuresFlowObfuscation.html",target:"_blank",rel:"noopener noreferrer"},p=a('<br><br><figure><img src="https://i.imgur.com/j2tZavr.png" alt="Exampel" tabindex="0" loading="lazy"><figcaption>Exampel</figcaption></figure><p><sub><em>Graph representing the two different approaches towards flow obfuscation between Zelix (17.0) and Skidfuscator (0.0.1)</em></sub><br><br><br></p><p>We currently are working on a variety of ways to approach this system using various lightweight obfuscation methods. Here are the current ones to date: Here are the features:</p><table><thead><tr><th>Feature</th><th>Type</th><th>Description</th><th>Status</th></tr></thead><tbody><tr><td><code>Flow GEN3</code></td><td>Flow (Community)</td><td>Obfuscates methods using the GEN3 Obfuscation methodology</td><td>‚úÖ</td></tr><tr><td><code>Bogus Jump</code></td><td>Flow (Community)</td><td>Invalid jump to some random generated code to prevent skidding</td><td>‚úÖ</td></tr><tr><td><code>Bogus Exception</code></td><td>Flow (Community)</td><td>Invalid jump to some random generated exception</td><td>‚úÖ</td></tr><tr><td><code>Mangled Jump</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Mutation to the jump condition to make it appear more complex than it actually is</td><td>‚ùå</td></tr><tr><td><code>Exception Jump</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Changes done to flow semantics by forcing an exception then handling all the code in the catch clause</td><td>‚ùå</td></tr><tr><td><code>Exception Return</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Throw an exception with the value and catch it as opposed to returning it (Very heavy)</td><td>‚ùå</td></tr><tr><td><code>Strong Opaque Predicate</code></td><td>Flow (Community)</td><td>Use heredity and method invocation to pass a predicate as opposed to declaring it at the beginning of the CFG</td><td>‚úÖ</td></tr><tr><td><code>Method Inlining</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Inline uncommon methods which aren&#39;t too big</td><td>‚ùå</td></tr><tr><td><code>Method Outlining</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Outline some non-sensitive blocks</td><td>‚ùå</td></tr><tr><td><code>Loop Unrolling</code></td><td>Flow (<strong>Enterprise</strong>)</td><td>Rewrite some loops instructions into continuous segments if the loop limit can be pre-determined</td><td>‚ùå</td></tr><tr><td><code>Flattening</code></td><td>Flow (Community)</td><td>Use a dispatcher method to harden the semantics of some block ranges (do not use entire method)</td><td>‚ö†Ô∏è</td></tr><tr><td><code>String Encryption</code></td><td>String</td><td>Encrypt the strings using the opaque predicate</td><td>‚úÖ</td></tr><tr><td><code>Reference Encryption</code></td><td>Reference</td><td>Encrypt the reference calls using InvokeDynamic using the opaque predicate</td><td>‚ùå</td></tr><tr><td><code>Reference Proxying</code></td><td>Reference</td><td>Proxy references using a builder pattern OR dispatcher classes (mostly for initialisation)</td><td>‚ùå</td></tr></tbody></table><h3 id="new-number-mutation" tabindex="-1"><a class="header-anchor" href="#new-number-mutation" aria-hidden="true">#</a> <em><strong>NEW</strong></em> Number Mutation</h3><figure><img src="https://i.imgur.com/XjUFdRU.png" alt="Graph" tabindex="0" loading="lazy"><figcaption>Graph</figcaption></figure><h3 id="switch-mutation" tabindex="-1"><a class="header-anchor" href="#switch-mutation" aria-hidden="true">#</a> Switch Mutation</h3><figure><img src="https://i.imgur.com/yPjFC8k.png" alt="Graph" tabindex="0" loading="lazy"><figcaption>Graph</figcaption></figure><h3 id="fake-exceptions" tabindex="-1"><a class="header-anchor" href="#fake-exceptions" aria-hidden="true">#</a> Fake exceptions</h3><figure><img src="https://i.imgur.com/bJcTNHm.png" alt="Graph" tabindex="0" loading="lazy"><figcaption>Graph</figcaption></figure><h3 id="fake-jumps" tabindex="-1"><a class="header-anchor" href="#fake-jumps" aria-hidden="true">#</a> Fake jumps</h3><figure><img src="https://i.imgur.com/780UIIc.png" alt="Graph" tabindex="0" loading="lazy"><figcaption>Graph</figcaption></figure><h1 id="credits" tabindex="-1"><a class="header-anchor" href="#credits" aria-hidden="true">#</a> Credits</h1><h2 id="libraries-used" tabindex="-1"><a class="header-anchor" href="#libraries-used" aria-hidden="true">#</a> Libraries used</h2>',16),u={href:"https://github.com/LLVM-but-worse/maple-ir",target:"_blank",rel:"noopener noreferrer"},g={href:"https://gitlab.ow2.org/asm/asm",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/sim0n/anti-java-agent/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/Col-E/Recaf",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/xxDark",target:"_blank",rel:"noopener noreferrer"},w=e("h2",{id:"inspired-from",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#inspired-from","aria-hidden":"true"},"#"),t(" Inspired from")],-1),x={href:"https://github.com/soot-oss/soot",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zelix.com",target:"_blank",rel:"noopener noreferrer"};function y(k,F){const o=s("ExternalLinkIcon");return i(),d("div",null,[h,e("p",null,[t("What is third generation flow obfuscation? Well, contrary to Zelix's "),e("a",l,[t("second generation flow obfuscation"),r(o)]),t(", we use an even more complex system with private and public seeds. Here's how it works:")]),p,e("ul",null,[e("li",null,[e("a",u,[t("Maple IR and the Team"),r(o)])]),e("li",null,[e("a",g,[t("ASM"),r(o)])]),e("li",null,[e("a",f,[t("AntiDumper by Sim0n"),r(o)])]),e("li",null,[e("a",m,[t("Recaf by Col-E"),r(o)])]),e("li",null,[e("a",b,[t("Some works by xDark"),r(o)])])]),w,e("ul",null,[e("li",null,[e("a",x,[t("Soot"),r(o)])]),e("li",null,[e("a",_,[t("Zelix KlassMaster"),r(o)])])])])}const v=n(c,[["render",y],["__file","index.html.vue"]]);export{v as default};
